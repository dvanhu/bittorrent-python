# app/main.py - full file: decode, info, peers, handshake, download_piece, download (assemble)
import json
import sys
import hashlib
import random
import socket
import os
import time
import struct
import tempfile
import shutil
from typing import Tuple, Any, Optional
from urllib.parse import urlencode, quote_from_bytes
import requests

# ---------- BENCODE DECODER WITH INFO_RAW CAPTURE ----------

def decode_bencode_capture_info(bencoded_value: bytes) -> Tuple[Any, Optional[bytes]]:
    value, next_index, info_raw = _decode_at_capture(bencoded_value, 0)
    if next_index != len(bencoded_value):
        raise ValueError("Extra data after valid bencode")
    return value, info_raw

def _decode_at_capture(b: bytes, idx: int):
    if idx >= len(b):
        raise ValueError("Unexpected EOF")

    c = chr(b[idx])

    # STRING
    if c.isdigit():
        colon = b.find(b":", idx)
        if colon == -1:
            raise ValueError("Invalid string: missing ':'")
        length = int(b[idx:colon].decode())
        start = colon + 1
        end = start + length
        if end > len(b): raise ValueError("Invalid string length")
        return b[start:end], end, None

    # INTEGER
    if c == "i":
        end = b.find(b"e", idx)
        if end == -1:
            raise ValueError("Invalid integer: missing 'e'")
        num = int(b[idx+1:end].decode())
        return num, end+1, None

    # LIST
    if c == "l":
        lst = []
        i = idx + 1
        info_raw = None
        while i < len(b) and b[i:i+1] != b"e":
            v, i, child_info = _decode_at_capture(b, i)
            lst.append(v)
            if child_info is not None:
                info_raw = child_info
        if i >= len(b) or b[i:i+1] != b"e":
            raise ValueError("Invalid list: missing 'e'")
        return lst, i+1, info_raw

    # DICT
    if c == "d":
        d = {}
        i = idx + 1
        info_raw = None
        while i < len(b) and b[i:i+1] != b"e":
            key_bytes, i, _child = _decode_at_capture(b, i)
            if not isinstance(key_bytes, (bytes, bytearray)):
                raise ValueError("Dict keys must be bytes")
            try:
                key = key_bytes.decode()
            except Exception:
                key = key_bytes.decode("latin-1")

            # capture raw bytes for "info"
            if key == "info":
                val_start = i
                val, i, child_raw = _decode_at_capture(b, i)
                val_end = i
                info_raw = b[val_start:val_end]
                d[key] = val
                continue

            val, i, child_info = _decode_at_capture(b, i)
            d[key] = val
            if child_info is not None:
                info_raw = child_info
        if i >= len(b) or b[i:i+1] != b"e":
            raise ValueError("Invalid dict: missing 'e'")
        return d, i+1, info_raw

    raise ValueError(f"Invalid bencode type at index {idx}: {c}")

# ---------- HELPERS ----------

def make_peer_id_bytes() -> bytes:
    """Return a 20-byte peer id (ASCII-safe deterministic)."""
    return b"-PC0001-123456789012"

def bytes_to_str_for_json(data):
    if isinstance(data, (bytes, bytearray)):
        try:
            return data.decode()
        except Exception:
            return data.decode("latin-1")
    raise TypeError(f"Type not serializable: {type(data)}")

# ---------- SIMPLE BENCODE DECODE COMMAND ----------

def cmd_decode(arg: str):
    bencoded = arg.encode()
    result, _ = decode_bencode_capture_info(bencoded)
    print(json.dumps(result, default=bytes_to_str_for_json))

# ---------- INFO COMMAND ----------

def cmd_info(torrent):
    with open(torrent, "rb") as f:
        raw = f.read()

    meta, info_raw = decode_bencode_capture_info(raw)
    if not isinstance(meta, dict):
        raise ValueError("Torrent top-level is not a dict")

    announce = meta.get("announce")
    if isinstance(announce, (bytes, bytearray)):
        try:
            announce_str = announce.decode()
        except Exception:
            announce_str = announce.decode("latin-1")
    else:
        announce_str = str(announce)

    info = meta.get("info")
    if not isinstance(info, dict):
        raise ValueError("info dict not found in torrent")

    length = info.get("length")
    piece_length = info.get("piece length")
    pieces_blob = info.get("pieces")

    if info_raw is None:
        raise ValueError("failed to capture raw info bytes for info_hash")

    info_hash_hex = hashlib.sha1(info_raw).hexdigest()

    print(f"Tracker URL: {announce_str}")
    print(f"Length: {length}")
    print(f"Info Hash: {info_hash_hex}")
    if piece_length is not None:
        print(f"Piece Length: {piece_length}")
    if pieces_blob is not None and isinstance(pieces_blob, (bytes, bytearray)):
        print("Piece Hashes:")
        for i in range(0, len(pieces_blob), 20):
            print(pieces_blob[i:i+20].hex())

# ---------- PEERS COMMAND ----------

def cmd_peers(torrent_path: str):
    with open(torrent_path, "rb") as f:
        raw = f.read()

    meta, info_raw = decode_bencode_capture_info(raw)
    if not isinstance(meta, dict):
        raise ValueError("Torrent top-level is not a dict")

    announce = meta.get("announce")
    if isinstance(announce, (bytes, bytearray)):
        try:
            announce_str = announce.decode()
        except Exception:
            announce_str = announce.decode("latin-1")
    else:
        announce_str = str(announce)

    info = meta.get("info")
    if not isinstance(info, dict):
        raise ValueError("info dict not found")
    length = info.get("length")
    if length is None:
        raise ValueError("length missing in info")

    if info_raw is None:
        raise ValueError("failed to capture raw info bytes for info_hash")

    info_hash_raw = hashlib.sha1(info_raw).digest()
    peer_id = make_peer_id_bytes()

    params = {
        "port": "6881",
        "uploaded": "0",
        "downloaded": "0",
        "left": str(length),
        "compact": "1"
    }
    qs = urlencode(params)

    encoded_info_hash = quote_from_bytes(info_hash_raw)
    encoded_peer_id  = quote_from_bytes(peer_id)

    sep = '&' if '?' in announce_str else '?'
    url = f"{announce_str}{sep}info_hash={encoded_info_hash}&peer_id={encoded_peer_id}&{qs}"

    print("Logs from your program will appear here!", file=sys.stderr)
    print(f"[debug] URL: {url}", file=sys.stderr)

    try:
        resp = requests.get(url, timeout=10)
        resp.raise_for_status()
    except Exception as e:
        raise RuntimeError(f"Tracker request failed: {e}")

    print(f"[debug] HTTP status: {resp.status_code}", file=sys.stderr)
    preview = resp.content[:400]
    try:
        print(f"[debug] Response preview (latin-1): {preview.decode('latin-1')}", file=sys.stderr)
    except Exception:
        print(f"[debug] Response preview (hex): {preview.hex()}", file=sys.stderr)

    tracker_meta, _ = decode_bencode_capture_info(resp.content)
    print(f"[debug] Parsed tracker response keys: {list(tracker_meta.keys()) if isinstance(tracker_meta, dict) else type(tracker_meta)}", file=sys.stderr)

    if not isinstance(tracker_meta, dict):
        raise ValueError("Tracker response is not a bencoded dict")

    if "failure reason" in tracker_meta:
        fr = tracker_meta["failure reason"]
        if isinstance(fr, (bytes, bytearray)):
            try:
                fr = fr.decode()
            except Exception:
                fr = fr.decode("latin-1")
        raise RuntimeError(f"Tracker returned failure reason: {fr}")

    peers_blob = tracker_meta.get("peers")
    if peers_blob is None:
        peers_list = tracker_meta.get("peers", None)
        if isinstance(peers_list, list):
            for peer in peers_list:
                ip = peer.get("ip")
                port = peer.get("port")
                if isinstance(ip, (bytes, bytearray)):
                    try:
                        ip = ip.decode()
                    except Exception:
                        ip = ip.decode("latin-1")
                print(f"{ip}:{port}")
            return
        raise ValueError("No 'peers' key in tracker response")

    if isinstance(peers_blob, (bytes, bytearray)):
        if len(peers_blob) % 6 != 0:
            raise ValueError("Peers blob length is not a multiple of 6")
        for i in range(0, len(peers_blob), 6):
            chunk = peers_blob[i:i+6]
            ip_bytes = chunk[:4]
            port_bytes = chunk[4:6]
            ip = ".".join(str(b) for b in ip_bytes)
            port = int.from_bytes(port_bytes, "big")
            print(f"{ip}:{port}")
        return

    raise ValueError("'peers' value has unsupported type")

# ---------- UTILS FOR PIECE DOWNLOAD ----------

def recv_exact(sock, n):
    data = b""
    while len(data) < n:
        chunk = sock.recv(n - len(data))
        if not chunk:
            raise RuntimeError("socket closed while reading")
        data += chunk
    return data

def read_message(sock, timeout=None):
    header = recv_exact(sock, 4)
    length = struct.unpack(">I", header)[0]
    if length == 0:
        return (None, None)
    body = recv_exact(sock, length)
    msg_id = body[0]
    payload = body[1:]
    return (msg_id, payload)

def send_message(sock, msg_id, payload=b""):
    length = 1 + len(payload)
    sock.sendall(struct.pack(">I", length) + bytes([msg_id]) + payload)

def get_peers_from_tracker(torrent_path):
    with open(torrent_path, "rb") as f:
        raw = f.read()
    meta, info_raw = decode_bencode_capture_info(raw)
    announce = meta.get("announce")
    if isinstance(announce, (bytes, bytearray)):
        try:
            announce_str = announce.decode()
        except Exception:
            announce_str = announce.decode("latin-1")
    else:
        announce_str = str(announce)
    info = meta.get("info")
    length = info.get("length")
    if info_raw is None:
        raise RuntimeError("failed to capture raw info bytes")
    info_hash_raw = hashlib.sha1(info_raw).digest()
    peer_id = make_peer_id_bytes()
    params = {
        "port": "6881",
        "uploaded": "0",
        "downloaded": "0",
        "left": str(length),
        "compact": "1"
    }
    qs = urlencode(params)
    encoded_info_hash = quote_from_bytes(info_hash_raw)
    encoded_peer_id = quote_from_bytes(peer_id)
    sep = '&' if '?' in announce_str else '?'
    url = f"{announce_str}{sep}info_hash={encoded_info_hash}&peer_id={encoded_peer_id}&{qs}"
    resp = requests.get(url, timeout=10)
    resp.raise_for_status()
    tracker_meta, _ = decode_bencode_capture_info(resp.content)
    peers_blob = tracker_meta.get("peers")
    peers = []
    if isinstance(peers_blob, (bytes, bytearray)):
        for i in range(0, len(peers_blob), 6):
            chunk = peers_blob[i:i+6]
            ip = ".".join(str(b) for b in chunk[:4])
            port = int.from_bytes(chunk[4:6], "big")
            peers.append((ip, port))
    return peers

def cmd_download_piece(out_path: str, torrent_path: str, piece_index: int, pipeline=5):
    with open(torrent_path, "rb") as f:
        raw = f.read()
    meta, info_raw = decode_bencode_capture_info(raw)
    if not isinstance(meta, dict):
        raise RuntimeError("torrent top-level not a dict")
    info = meta.get("info")
    if not isinstance(info, dict):
        raise RuntimeError("info dict missing")
    piece_length = info.get("piece length")
    pieces_blob = info.get("pieces")
    if pieces_blob is None or not isinstance(pieces_blob, (bytes, bytearray)):
        raise RuntimeError("pieces blob missing")
    total_pieces = len(pieces_blob) // 20
    if piece_index < 0 or piece_index >= total_pieces:
        raise ValueError("piece_index out of range")
    expected_piece_hash = pieces_blob[piece_index*20:(piece_index+1)*20]
    peers = get_peers_from_tracker(torrent_path)
    if not peers:
        raise RuntimeError("no peers from tracker")
    ip, port = peers[0]

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(8)
    try:
        sock.connect((ip, port))
    except Exception as e:
        sock.close()
        raise RuntimeError(f"connect to {ip}:{port} failed: {e}")
    try:
        info_hash_raw = hashlib.sha1(info_raw).digest()
        our_peer_id = make_peer_id_bytes()
        pstr = b"BitTorrent protocol"
        handshake = bytes([len(pstr)]) + pstr + (b"\x00"*8) + info_hash_raw + our_peer_id
        sock.sendall(handshake)

        expected = 1 + len(pstr) + 8 + 20 + 20
        data = recv_exact(sock, expected)
        remote_pstrlen = data[0]
        remote_pstr = data[1:1+remote_pstrlen]
        offset = 1 + remote_pstrlen
        offset += 8
        remote_info_hash = data[offset:offset+20]; offset += 20
        remote_peer_id = data[offset:offset+20]
        if remote_info_hash != info_hash_raw:
            print("Warning: remote info_hash mismatch", file=sys.stderr)

        # Wait for bitfield or unchoke
        while True:
            msg_id, payload = read_message(sock)
            if msg_id is None:
                continue
            if msg_id == 5 or msg_id == 1:
                break

        send_message(sock, 2, b"")

        while True:
            msg_id, payload = read_message(sock)
            if msg_id is None:
                continue
            if msg_id == 1:
                break

        block_size = 16 * 1024
        file_length = info.get("length")
        if piece_index == total_pieces - 1 and file_length is not None:
            expected_piece_size = file_length - (piece_length * (total_pieces - 1))
        else:
            expected_piece_size = piece_length

        piece_data = bytearray(expected_piece_size)

        blocks = []
        begin = 0
        while begin < expected_piece_size:
            this_len = min(block_size, expected_piece_size - begin)
            blocks.append((begin, this_len))
            begin += this_len

        pending = {}
        to_request = list(blocks)
        received = {}

        while to_request or pending:
            while to_request and len(pending) < pipeline:
                begin, blen = to_request.pop(0)
                payload = struct.pack(">III", piece_index, begin, blen)
                send_message(sock, 6, payload)
                pending[begin] = blen

            msg_id, payload = read_message(sock)
            if msg_id is None:
                continue
            if msg_id == 7:
                if len(payload) < 8:
                    raise RuntimeError("invalid piece message")
                idx = struct.unpack(">I", payload[0:4])[0]
                bgn = struct.unpack(">I", payload[4:8])[0]
                block = payload[8:]
                received[bgn] = block
                if bgn in pending:
                    del pending[bgn]

        for bgn, blen in blocks:
            blk = received.get(bgn)
            if blk is None:
                raise RuntimeError(f"missing block at {bgn}")
            piece_data[bgn:bgn+len(blk)] = blk

        actual_hash = hashlib.sha1(bytes(piece_data)).digest()
        if actual_hash != expected_piece_hash:
            raise RuntimeError("piece hash mismatch")

        # ensure directory exists
        out_dir = os.path.dirname(out_path)
        if out_dir and not os.path.exists(out_dir):
            os.makedirs(out_dir, exist_ok=True)

        with open(out_path, "wb") as fo:
            fo.write(piece_data)

        print(f"Downloaded piece {piece_index} -> {out_path}")

    finally:
        sock.close()

# ---------- HANDSHAKE COMMAND ----------

def cmd_handshake(torrent_path: str, peer_addr: str):
    with open(torrent_path, "rb") as f:
        raw = f.read()

    meta, info_raw = decode_bencode_capture_info(raw)
    if not isinstance(meta, dict):
        raise ValueError("torrent top-level is not a dict")
    if info_raw is None:
        raise ValueError("failed to capture raw info bytes for hashing")

    info_hash_raw = hashlib.sha1(info_raw).digest()
    our_peer_id = b"-PC0001-123456789012"

    pstr = b"BitTorrent protocol"
    pstrlen = bytes([len(pstr)])
    reserved = b"\x00" * 8
    handshake = pstrlen + pstr + reserved + info_hash_raw + our_peer_id

    if ":" not in peer_addr:
        raise ValueError("peer address must be ip:port")
    ip, port_s = peer_addr.rsplit(":", 1)
    try:
        port = int(port_s)
    except ValueError:
        raise ValueError("invalid port")

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(8)
    try:
        sock.connect((ip, port))
    except Exception as e:
        sock.close()
        raise RuntimeError(f"TCP connect to {ip}:{port} failed: {e}")

    try:
        sock.sendall(handshake)

        expected = 1 + len(pstr) + 8 + 20 + 20
        data = b""
        start = time.time()
        while len(data) < expected:
            chunk = sock.recv(expected - len(data))
            if not chunk:
                break
            data += chunk
            if time.time() - start > 10:
                break

        if len(data) < expected:
            raise RuntimeError(f"Incomplete handshake received ({len(data)} bytes)")

        remote_pstrlen = data[0]
        remote_pstr = data[1:1+remote_pstrlen]
        offset = 1 + remote_pstrlen
        remote_reserved = data[offset:offset+8]; offset += 8
        remote_info_hash = data[offset:offset+20]; offset += 20
        remote_peer_id = data[offset:offset+20]

        if remote_pstr != pstr:
            print("Warning: remote pstr differs", file=sys.stderr)
        if remote_info_hash != info_hash_raw:
            print("Warning: remote info_hash doesn't match the torrent's info_hash", file=sys.stderr)

        print(f"Peer ID: {remote_peer_id.hex()}")

    finally:
        sock.close()

# ---------- DOWNLOAD (assemble whole file) ----------

def cmd_download(out_path: str, torrent_path: str):
    with open(torrent_path, "rb") as f:
        raw = f.read()
    meta, info_raw = decode_bencode_capture_info(raw)
    if not isinstance(meta, dict):
        raise RuntimeError("torrent top-level not a dict")
    info = meta.get("info")
    if not isinstance(info, dict):
        raise RuntimeError("info dict missing")
    pieces_blob = info.get("pieces")
    if pieces_blob is None or not isinstance(pieces_blob, (bytes, bytearray)):
        raise RuntimeError("pieces blob missing")
    piece_length = info.get("piece length")
    total_pieces = len(pieces_blob) // 20

    tmpdir = tempfile.mkdtemp(prefix="bt-pieces-")
    piece_paths = []
    try:
        for idx in range(total_pieces):
            print(f"Downloading piece {idx+1}/{total_pieces}...", file=sys.stderr)
            tmp_piece_path = os.path.join(tmpdir, f"piece-{idx}.bin")
            try:
                cmd_download_piece(tmp_piece_path, torrent_path, idx)
            except Exception as e:
                raise RuntimeError(f"Failed to download piece {idx}: {e}")
            piece_paths.append(tmp_piece_path)

        # ensure output directory exists
        out_dir = os.path.dirname(out_path)
        if out_dir and not os.path.exists(out_dir):
            os.makedirs(out_dir, exist_ok=True)

        with open(out_path, "wb") as out_f:
            for pth in piece_paths:
                with open(pth, "rb") as pf:
                    shutil.copyfileobj(pf, out_f)

        if "length" in info:
            expected_length = info.get("length")
            actual_length = os.path.getsize(out_path)
            if actual_length != expected_length:
                raise RuntimeError(f"Final file size mismatch: expected {expected_length}, got {actual_length}")

        print(f"Downloaded and assembled file -> {out_path}")

    finally:
        try:
            shutil.rmtree(tmpdir)
        except Exception:
            pass

# ---------- MAIN ----------

def main():
    print("Logs from your program will appear here!", file=sys.stderr)

    if len(sys.argv) < 2:
        print("Usage: python app/main.py <command> <args>", file=sys.stderr)
        sys.exit(2)

    cmd = sys.argv[1]

    if cmd == "decode":
        if len(sys.argv) < 3:
            raise ValueError("Missing argument for decode")
        cmd_decode(sys.argv[2])
    elif cmd == "info":
        if len(sys.argv) < 3:
            raise ValueError("Missing path for info")
        cmd_info(sys.argv[2])
    elif cmd == "peers":
        if len(sys.argv) < 3:
            raise ValueError("Missing path for peers")
        cmd_peers(sys.argv[2])
    elif cmd == "handshake":
        if len(sys.argv) < 4:
            raise ValueError("Usage: python app/main.py handshake <torrent> <peer_ip:peer_port>")
        cmd_handshake(sys.argv[2], sys.argv[3])
    elif cmd == "download_piece":
        if len(sys.argv) < 6:
            raise ValueError("Usage: python app/main.py download_piece -o <out_path> <torrent_path> <piece_index>")
        if sys.argv[2] != "-o":
            raise ValueError("Use -o <out_path> before torrent path")
        out_path = sys.argv[3]
        torrent_path = sys.argv[4]
        piece_index = int(sys.argv[5])
        cmd_download_piece(out_path, torrent_path, piece_index)
    elif cmd == "download":
        if len(sys.argv) < 4:
            raise ValueError("Usage: python app/main.py download -o <out_path> <torrent_path>")
        if sys.argv[2] != "-o":
            raise ValueError("Use -o <out_path> before torrent path")
        out_path = sys.argv[3]
        torrent_path = sys.argv[4]
        cmd_download(out_path, torrent_path)
    else:
        raise NotImplementedError(f"Unknown command {cmd}")

if __name__ == "__main__":
    main()
# End of app/main.py
